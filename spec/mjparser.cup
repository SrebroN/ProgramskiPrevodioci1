package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code{:
	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected=false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal String IDENT;
terminal Integer NUMBER,BOOL;
terminal Character CHARACTER;
terminal PROG, OPBRACKET, CLBRACKET, CONST, SEMI, ASSIGN, COMMA, OPSQBRACKET, CLSQBRACKET, OPPAREN, CLPAREN;
terminal VOID, EQUAL, NOTEQUAL, GREATER, GREATEREQUAL, LESS, LESSEQUAL, PLUS, MINUS, MUL, DIV, MOD, UNION;
terminal IF, BREAK, CONTINUE, RETURN, READ, DO, WHILE, DOT, NEW, MAP, AND, OR, INC, DEC, ELSE, PRINT, COLON;

nonterminal Program, ConVarDecList, MethodDecList, ConDecList, VarDecList, ConDecl, Constant;
nonterminal ConDeclMore, VarDecMore, MethodSignatureType, FormParsOpt;
nonterminal FormPars, FormParsMore, MethodDecl, VarDecOpt, StatementOpt, Statement, ActPars, ActParsExprOpt;
nonterminal DesignatorStatement, ActParsList, ActParsMore, ActParsListBegin;
nonterminal Assignop, Relop, Addop, Mulop, Setop, Label, DesignatorList;
nonterminal FactorAct, ExprOpt, DoNonterm;
nonterminal ConditionList, ElseStatement, NumConstOpt, ProgramName, VarDec;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Expr, AddOpTerm, Term, MulopFactor;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondFact, CondTerm, Condition, Type;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, DesignatorArrayName, DesignatorMeth;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodSignAndName;
precedence left ELSE;

Program ::= (Program) PROG ProgramName ConVarDecList OPBRACKET MethodDecList CLBRACKET;

ProgramName ::= (ProgramName) IDENT;


ConVarDecList ::=   (ConVarDecList_con) ConVarDecList ConDecList
					|
					(ConVarDecList_var) ConVarDecList VarDecList
					|
					(ConVarDecList_epsilon) /*epsilon*/
					;

ConDecList ::= (ConDecList) CONST Type ConDecl ConDeclMore SEMI;

Type ::= (Type) IDENT;

ConDecl ::= (ConDecl) IDENT ASSIGN Constant;

ConDeclMore::= (ConDeclMore_comma) COMMA ConDecl ConDeclMore
				|
				(ConDeclMore_e) /*epsilon*/
				;
				
Constant ::= (Constant_n) NUMBER
			|
			(Constant_c) CHARACTER
			|
			(Constant_b) BOOL
			;

VarDecList ::= (VarDecList) Type VarDec VarDecMore SEMI;

VarDec	::=	(VarDec_var) IDENT
			|
			(VarDec_arr) IDENT OPSQBRACKET CLSQBRACKET
			;

VarDecMore ::= 	(VarDecMore_m) COMMA VarDec VarDecMore
				|
				(VarDecMore_e)/*epsilon*/
				;


MethodDecList ::= 	(MethodDecList_m) MethodDecList MethodDecl
					|
					(MethodDecList_e)/*epsilon*/
					;
					
MethodDecl ::= (MethodDecl)  MethodSignAndName OPPAREN FormParsOpt CLPAREN VarDecOpt OPBRACKET StatementOpt CLBRACKET;

MethodSignAndName ::= 	(MethodSignAndName_Type) Type IDENT
						|
						(MethodSignAndName_Void) VOID IDENT
						;

FormParsOpt ::= (FormParsOpt_fm) FormPars FormParsMore
				|
				(FormParsOpt_e) /*epsilon*/
				;

FormPars ::= 	(FormPars_var) Type IDENT
				|
				(FormPars_arr) Type IDENT OPSQBRACKET CLSQBRACKET
				;

FormParsMore ::= 	(FormParsMore_m) COMMA FormPars FormParsMore
					|
					(FormParsMore_e)/*epsilon*/
					;

VarDecOpt ::= 	(VarDecOpt_v) VarDecOpt VarDecList
				|
				(VarDecOpt_e)/*epsilon*/
				;
				
StatementOpt ::= 	(StatementOpt_s) StatementOpt Statement
					|
					(StatementOpt_e)/*epsilon*/
					;
					
Statement ::= 	(Statement_ds) DesignatorStatement SEMI  				
				|
				(Statement_if) IF OPPAREN Condition CLPAREN Statement ElseStatement
				|
				(Statement_br) BREAK SEMI 
				|
				(Statement_cont) CONTINUE SEMI 
				|
				(Statement_ret) RETURN SEMI 						
				|
				(Statement_retexpr) RETURN Expr SEMI 						
				|
				(Statement_rd) READ OPPAREN Designator CLPAREN SEMI 	
				|
				(Statement_pr) PRINT OPPAREN Expr CLPAREN SEMI 
				|				
				(Statement_prnum) PRINT OPPAREN Expr COMMA NUMBER CLPAREN SEMI 
				|
				(Statement_do) DoNonterm Statement WHILE OPPAREN ConditionList CLPAREN SEMI 
				|
				(Statement_st) OPBRACKET StatementOpt CLBRACKET 
				;

DoNonterm	::=(DoNonterm) DO;

ElseStatement ::=	(ElseStatement_else) ELSE Statement
					|
					(ElseStatement_E)/*epsilon*/
					;

NumConstOpt ::=	(NumConstOpt_cn) COMMA NUMBER
				|
				(NumConstOpt_e)/*epsilon*/
				;
					
ConditionList ::= 	(ConditionList_con) Condition
					|
					(ConditionList_cond) Condition COMMA DesignatorStatement
					|
					(ConditionList_e)/*epsilon*/
					;

					
Designator ::= 	(Designator_var) IDENT
				|
				(Designator_elem) DesignatorArrayName OPSQBRACKET Expr CLSQBRACKET;
	
DesignatorArrayName ::= (DesignatorArrayName) IDENT;

DesignatorStatement ::= (DesignatorStatement_assigexpr) Designator Assignop Expr
						|
						(DesignatorStatement_actpars) DesignatorMeth OPPAREN ActParsList CLPAREN
						|
						(DesignatorStatement_inc) Designator INC
						|
						(DesignatorStatement_dec) Designator DEC
						|
						(DesignatorStatement_assign) Designator Assignop Designator Setop Designator
						; 
							
DesignatorMeth	::=	(DesignatorMeth) IDENT;

ActParsList ::=	(ActParsList_par) ActParsListBegin ActPars ActParsMore
				|
				(ActParsList_e) ActParsListBegin
				;
				
ActParsListBegin ::= (ActParsListBegin) /*epsilon*/;

ActPars ::=	(ActPars) Expr;

ActParsMore	::=	(ActParsMore_more) COMMA ActPars ActParsMore
				|
				(ActParsMore_e)/*epsilon*/
				;
					
Condition ::= 	(Condition_or) Condition OR CondTerm
				|
				(Condition_cond) CondTerm
				;

CondTerm ::= 	(CondTerm_and) CondTerm AND CondFact
				|
				(CondTerm_cond) CondFact
				;

CondFact ::= 	(CondFact_rel) Expr Relop Expr
				|
				(CondFact_single) Expr
				;
 
Expr ::= 	(Expr_term) AddOpTerm
			|
			(Expr_mint) MINUS AddOpTerm
			|
			(Expr_des) Designator MAP Designator
			;
			
ExprOpt ::=	(ExprOpt_exp) Expr
			|
			(ExprOpt_e) /*epsilon*/
			;

AddOpTerm ::=	(AddOpTerm_op) AddOpTerm Addop Term
				|
				(AddOpTerm_term) Term
				;

Term ::=	(Term)  MulopFactor;

MulopFactor ::=	(MulopFactor_mul) MulopFactor Mulop Factor
				|
				(MulopFactor_fac) Factor
				;
					
Factor ::= 	(Factor_des) Designator
			|
			(Factor_meth) Designator OPPAREN ActParsList CLPAREN
			|
			(Factor_num) NUMBER
			|
			(Factor_char) CHARACTER
			|
			(Factor_bool) BOOL
			|
			(Factor_newexpr) NEW Type OPSQBRACKET Expr CLSQBRACKET
			|
			(Factor_expr) OPPAREN Expr CLPAREN
			;		
					
FactorAct ::=	(FactorAct_fa) OPPAREN ActParsList CLPAREN
				|
				(FactorAct_e)/*epsilon*/
				;
					
Label ::= (Label) IDENT; 

Assignop ::= (Assignop) ASSIGN;

Relop ::= 	(Relop_eq) EQUAL
			|
			(Relop_neq) NOTEQUAL
			|
			(Relop_gr) GREATER
			|
			(Relop_greq) GREATEREQUAL
			|
			(Relop_l) LESS
			|
			(Relop_leq) LESSEQUAL
			;
				
Addop ::= 	(Addop_p) PLUS
			|
			(Addop_m) MINUS
			;
			
Mulop ::=	(Mulop_m) MUL
			|
			(Mulop_d) DIV
			|
			(Mulop_md) MOD
			;

Setop ::= (Setop) UNION;
				
			