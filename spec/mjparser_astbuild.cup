package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code{:
	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected=false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal String IDENT;
terminal Integer NUMBER,BOOL;
terminal Character CHARACTER;
terminal PROG, OPBRACKET, CLBRACKET, CONST, SEMI, ASSIGN, COMMA, OPSQBRACKET, CLSQBRACKET, OPPAREN, CLPAREN;
terminal VOID, EQUAL, NOTEQUAL, GREATER, GREATEREQUAL, LESS, LESSEQUAL, PLUS, MINUS, MUL, DIV, MOD, UNION;
terminal IF, BREAK, CONTINUE, RETURN, READ, DO, WHILE, DOT, NEW, MAP, AND, OR, INC, DEC, ELSE, PRINT, COLON;

nonterminal Program Program;
nonterminal ConVarDecList ConVarDecList;
nonterminal MethodDecList MethodDecList;
nonterminal ConDecList ConDecList;
nonterminal VarDecList VarDecList;
nonterminal ConDecl ConDecl;
nonterminal Constant Constant;
nonterminal ConDeclMore ConDeclMore;
nonterminal VarDecMore VarDecMore;
nonterminal MethodSignatureType MethodSignatureType;
nonterminal FormParsOpt FormParsOpt;
nonterminal FormPars FormPars;
nonterminal FormParsMore FormParsMore;
nonterminal MethodDecl MethodDecl;
nonterminal VarDecOpt VarDecOpt;
nonterminal StatementOpt StatementOpt;
nonterminal Statement Statement;
nonterminal ActPars ActPars;
nonterminal ActParsExprOpt ActParsExprOpt;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ActParsList ActParsList;
nonterminal ActParsMore ActParsMore;
nonterminal ActParsListBegin ActParsListBegin;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal Setop Setop;
nonterminal Label Label;
nonterminal DesignatorList DesignatorList;
nonterminal DoNonterm DoNonterm;
nonterminal Else Else;
nonterminal While While;
nonterminal ConditionList ConditionList;
nonterminal ElseStatement ElseStatement;
nonterminal ProgramName ProgramName;
nonterminal VarDec VarDec;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor, Expr, AddOpTerm, Term, MulopFactor;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondFact, CondTerm, Condition, Type, FactorNeg, CondList, ConditionTerm;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, DesignatorArrayName, DesignatorMeth;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodSignAndName;
precedence left ELSE;

Program ::= (Program) PROG ProgramName:P1 ConVarDecList:C2 OPBRACKET MethodDecList:M3 CLBRACKET {: RESULT=new Program(P1, C2, M3); RESULT.setLine(P1left); :};

ProgramName ::= (ProgramName) IDENT:I1 {: RESULT=new ProgramName(I1); RESULT.setLine(I1left); :};


ConVarDecList ::=   (ConVarDecList_con) ConVarDecList:C1 ConDecList:C2 {: RESULT=new ConVarDecList_con(C1, C2); RESULT.setLine(C1left); :}
					|
					(ConVarDecList_var) ConVarDecList:C1 VarDecList:V2 {: RESULT=new ConVarDecList_var(C1, V2); RESULT.setLine(C1left); :}
					|
					(ConVarDecList_epsilon) {: RESULT=new ConVarDecList_epsilon(); :} /*epsilon*/
					;

ConDecList ::= (ConDecList) CONST Type:T1 ConDecl:C2 ConDeclMore:C3 SEMI {: RESULT=new ConDecList(T1, C2, C3); RESULT.setLine(T1left); :};

Type ::= (Type) IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};

ConDecl ::= (ConDecl) IDENT:I1 ASSIGN Constant:C2 {: RESULT=new ConDecl(I1, C2); RESULT.setLine(I1left); :};

ConDeclMore::= (ConDeclMore_comma) COMMA ConDecl:C1 ConDeclMore:C2 {: RESULT=new ConDeclMore_comma(C1, C2); RESULT.setLine(C1left); :}
				|
				(ConDeclMore_e) {: RESULT=new ConDeclMore_e(); :} /*epsilon*/
				;
				
Constant ::= (Constant_n) NUMBER:N1 {: RESULT=new Constant_n(N1); RESULT.setLine(N1left); :}
			|
			(Constant_c) CHARACTER:C1 {: RESULT=new Constant_c(C1); RESULT.setLine(C1left); :}
			|
			(Constant_b) BOOL:B1 {: RESULT=new Constant_b(B1); RESULT.setLine(B1left); :}
			;

VarDecList ::= (VarDecList_v) Type:T1 VarDec:V2 VarDecMore:V3 SEMI {: RESULT=new VarDecList_v(T1, V2, V3); RESULT.setLine(T1left); :}
				|
				(VarDecList_error) error:e
				{:parser.report_error("Oporavak od greske u VarDecu: ",null); :} {: RESULT=new VarDecList_error(); :}
				;

VarDec	::=	(VarDec_var) IDENT:I1 {: RESULT=new VarDec_var(I1); RESULT.setLine(I1left); :}
			|
			(VarDec_arr) IDENT:I1 OPSQBRACKET CLSQBRACKET {: RESULT=new VarDec_arr(I1); RESULT.setLine(I1left); :}
			;

VarDecMore ::= 	(VarDecMore_m) COMMA VarDec:V1 VarDecMore:V2 {: RESULT=new VarDecMore_m(V1, V2); RESULT.setLine(V1left); :}
				|
				(VarDecMore_e) {: RESULT=new VarDecMore_e(); :}/*epsilon*/
				;


MethodDecList ::= 	(MethodDecList_m) MethodDecList:M1 MethodDecl:M2 {: RESULT=new MethodDecList_m(M1, M2); RESULT.setLine(M1left); :}
					|
					(MethodDecList_e) {: RESULT=new MethodDecList_e(); :}/*epsilon*/
					;
					
MethodDecl ::= (MethodDecl)  MethodSignAndName:M1 OPPAREN FormParsOpt:F2 CLPAREN VarDecOpt:V3 OPBRACKET StatementOpt:S4 CLBRACKET {: RESULT=new MethodDecl(M1, F2, V3, S4); RESULT.setLine(M1left); :};

MethodSignAndName ::= 	(MethodSignAndName_Type) Type:T1 IDENT:I2 {: RESULT=new MethodSignAndName_Type(T1, I2); RESULT.setLine(T1left); :}
						|
						(MethodSignAndName_Void) VOID IDENT:I1 {: RESULT=new MethodSignAndName_Void(I1); RESULT.setLine(I1left); :}
						;

FormParsOpt ::= (FormParsOpt_fm) FormPars:F1 FormParsMore:F2 {: RESULT=new FormParsOpt_fm(F1, F2); RESULT.setLine(F1left); :}
				|
				(FormParsOpt_e) {: RESULT=new FormParsOpt_e(); :} /*epsilon*/
				;

FormPars ::= 	(FormPars_var) Type:T1 IDENT:I2 {: RESULT=new FormPars_var(T1, I2); RESULT.setLine(T1left); :}
				|
				(FormPars_arr) Type:T1 IDENT:I2 OPSQBRACKET CLSQBRACKET {: RESULT=new FormPars_arr(T1, I2); RESULT.setLine(T1left); :}
				|
				(FormPars_err) error:e
				{:parser.report_error("Oporavak od greske u FormPars: ",null); :} {: RESULT=new FormPars_err(); :}
				;

FormParsMore ::= 	(FormParsMore_m) COMMA FormPars:F1 FormParsMore:F2 {: RESULT=new FormParsMore_m(F1, F2); RESULT.setLine(F1left); :}
					|
					(FormParsMore_e) {: RESULT=new FormParsMore_e(); :}/*epsilon*/
					;

VarDecOpt ::= 	(VarDecOpt_v) VarDecOpt:V1 VarDecList:V2 {: RESULT=new VarDecOpt_v(V1, V2); RESULT.setLine(V1left); :}
				|
				(VarDecOpt_e) {: RESULT=new VarDecOpt_e(); :}/*epsilon*/
				;
				
StatementOpt ::= 	(StatementOpt_s) StatementOpt:S1 Statement:S2 {: RESULT=new StatementOpt_s(S1, S2); RESULT.setLine(S1left); :}
					|
					(StatementOpt_e) {: RESULT=new StatementOpt_e(); :}/*epsilon*/
					;
					
Statement ::= 	(Statement_ds) DesignatorStatement:D1 SEMI {: RESULT=new Statement_ds(D1); RESULT.setLine(D1left); :}  				
				|
				(Statement_if) IF OPPAREN CondList:C1 CLPAREN Statement:S2 ElseStatement:E3 {: RESULT=new Statement_if(C1, S2, E3); RESULT.setLine(C1left); :}
				|
				(Statement_br) BREAK SEMI {: RESULT=new Statement_br(); :} 
				|
				(Statement_cont) CONTINUE SEMI {: RESULT=new Statement_cont(); :} 
				|
				(Statement_ret) RETURN SEMI {: RESULT=new Statement_ret(); :} 						
				|
				(Statement_retexpr) RETURN Expr:E1 SEMI {: RESULT=new Statement_retexpr(E1); RESULT.setLine(E1left); :} 						
				|
				(Statement_rd) READ OPPAREN Designator:D1 CLPAREN SEMI {: RESULT=new Statement_rd(D1); RESULT.setLine(D1left); :} 	
				|
				(Statement_pr) PRINT OPPAREN Expr:E1 CLPAREN SEMI {: RESULT=new Statement_pr(E1); RESULT.setLine(E1left); :} 
				|				
				(Statement_prnum) PRINT OPPAREN Expr:E1 COMMA NUMBER:N2 CLPAREN SEMI {: RESULT=new Statement_prnum(E1, N2); RESULT.setLine(E1left); :} 
				|
				(Statement_do) DoNonterm:D1 Statement:S2 While:W3 OPPAREN ConditionList:C4 CLPAREN SEMI {: RESULT=new Statement_do(D1, S2, W3, C4); RESULT.setLine(D1left); :} 
				|
				(Statement_st) OPBRACKET StatementOpt:S1 CLBRACKET {: RESULT=new Statement_st(S1); RESULT.setLine(S1left); :} 
				;

While ::=(While)WHILE {: RESULT=new While(); :};

DoNonterm	::=(DoNonterm) DO {: RESULT=new DoNonterm(); :};

ElseStatement ::=	(ElseStatement_else) Else:E1 Statement:S2 {: RESULT=new ElseStatement_else(E1, S2); RESULT.setLine(E1left); :}
					|
					(ElseStatement_E) {: RESULT=new ElseStatement_E(); :}/*epsilon*/
					;

Else ::= (Else) ELSE {: RESULT=new Else(); :};
					
ConditionList ::= 	(ConditionList_con) CondList:C1 {: RESULT=new ConditionList_con(C1); RESULT.setLine(C1left); :}
					|
					(ConditionList_cond) CondList:C1 COMMA DesignatorStatement:D2 {: RESULT=new ConditionList_cond(C1, D2); RESULT.setLine(C1left); :}
					|
					(ConditionList_e) {: RESULT=new ConditionList_e(); :}/*epsilon*/
					;

					
Designator ::= 	(Designator_var) IDENT:I1 {: RESULT=new Designator_var(I1); RESULT.setLine(I1left); :}
				|
				(Designator_elem) DesignatorArrayName:D1 OPSQBRACKET Expr:E2 CLSQBRACKET {: RESULT=new Designator_elem(D1, E2); RESULT.setLine(D1left); :};
	
DesignatorArrayName ::= (DesignatorArrayName) IDENT:I1 {: RESULT=new DesignatorArrayName(I1); RESULT.setLine(I1left); :};

DesignatorStatement ::= (DesignatorStatement_assigexpr) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorStatement_assigexpr(D1, A2, E3); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_error) error:e
						{:parser.report_error("Oporavak od greske u Designator Statemntu: " +eleft,null); :} {: RESULT=new DesignatorStatement_error(); :}
						|
						(DesignatorStatement_actpars) DesignatorMeth:D1 OPPAREN ActParsList:A2 CLPAREN {: RESULT=new DesignatorStatement_actpars(D1, A2); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_inc) Designator:D1 INC {: RESULT=new DesignatorStatement_inc(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_dec) Designator:D1 DEC {: RESULT=new DesignatorStatement_dec(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_assign) Designator:D1 Assignop:A2 Designator:D3 Setop:S4 Designator:D5 {: RESULT=new DesignatorStatement_assign(D1, A2, D3, S4, D5); RESULT.setLine(D1left); :}
						; 
							
DesignatorMeth	::=	(DesignatorMeth) IDENT:I1 {: RESULT=new DesignatorMeth(I1); RESULT.setLine(I1left); :};

ActParsList ::=	(ActParsList_par) ActParsListBegin:A1 ActPars:A2 ActParsMore:A3 {: RESULT=new ActParsList_par(A1, A2, A3); RESULT.setLine(A1left); :}
				|
				(ActParsList_e) ActParsListBegin:A1 {: RESULT=new ActParsList_e(A1); RESULT.setLine(A1left); :}
				;
				
ActParsListBegin ::= (ActParsListBegin) {: RESULT=new ActParsListBegin(); :} /*epsilon*/;

ActPars ::=	(ActPars) Expr:E1 {: RESULT=new ActPars(E1); RESULT.setLine(E1left); :};

ActParsMore	::=	(ActParsMore_more) COMMA ActPars:A1 ActParsMore:A2 {: RESULT=new ActParsMore_more(A1, A2); RESULT.setLine(A1left); :}
				|
				(ActParsMore_e) {: RESULT=new ActParsMore_e(); :}/*epsilon*/
				;
					
CondList ::=	(CondList_cond) Condition:C1 {: RESULT=new CondList_cond(C1); RESULT.setLine(C1left); :}
				|
				(CondList_error) error:e
				{:parser.report_error("Oporavak od greske u If uslovu: ",null); :} {: RESULT=new CondList_error(); :}
				;
					
Condition ::= 	(Condition_or) Condition:C1 OR ConditionTerm:C2 {: RESULT=new Condition_or(C1, C2); RESULT.setLine(C1left); :}
				|
				(Condition_cond) ConditionTerm:C1 {: RESULT=new Condition_cond(C1); RESULT.setLine(C1left); :}
				;

ConditionTerm ::= (ConditionTerm) CondTerm:C1 {: RESULT=new ConditionTerm(C1); RESULT.setLine(C1left); :};

CondTerm ::= 	(CondTerm_and) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTerm_and(C1, C2); RESULT.setLine(C1left); :}
				|
				(CondTerm_cond) CondFact:C1 {: RESULT=new CondTerm_cond(C1); RESULT.setLine(C1left); :}
				;

CondFact ::= 	(CondFact_rel) Expr:E1 Relop:R2 Expr:E3 {: RESULT=new CondFact_rel(E1, R2, E3); RESULT.setLine(E1left); :}
				|
				(CondFact_single) Expr:E1 {: RESULT=new CondFact_single(E1); RESULT.setLine(E1left); :}
				;
 
Expr ::= 	(Expr_term) AddOpTerm:A1 {: RESULT=new Expr_term(A1); RESULT.setLine(A1left); :}
			|
			(Expr_des) Designator:D1 MAP Designator:D2 {: RESULT=new Expr_des(D1, D2); RESULT.setLine(D1left); :}
			;
			

AddOpTerm ::=	(AddOpTerm_op) AddOpTerm:A1 Addop:A2 Term:T3 {: RESULT=new AddOpTerm_op(A1, A2, T3); RESULT.setLine(A1left); :}
				|
				(AddOpTerm_term) Term:T1 {: RESULT=new AddOpTerm_term(T1); RESULT.setLine(T1left); :}
				;

Term ::=	(Term)  MulopFactor:M1 {: RESULT=new Term(M1); RESULT.setLine(M1left); :};

MulopFactor ::=	(MulopFactor_mul) MulopFactor:M1 Mulop:M2 FactorNeg:F3 {: RESULT=new MulopFactor_mul(M1, M2, F3); RESULT.setLine(M1left); :}
				|
				(MulopFactor_fac) FactorNeg:F1 {: RESULT=new MulopFactor_fac(F1); RESULT.setLine(F1left); :}
				;
					
FactorNeg	::=	(FactorNeg_fac) Factor:F1 {: RESULT=new FactorNeg_fac(F1); RESULT.setLine(F1left); :}
				|
				(FactorNeg_neg) MINUS Factor:F1 {: RESULT=new FactorNeg_neg(F1); RESULT.setLine(F1left); :}
				;
					
Factor ::= 	(Factor_des) Designator:D1 {: RESULT=new Factor_des(D1); RESULT.setLine(D1left); :}
			|
			(Factor_meth) Designator:D1 OPPAREN ActParsList:A2 CLPAREN {: RESULT=new Factor_meth(D1, A2); RESULT.setLine(D1left); :}
			|
			(Factor_num) NUMBER:N1 {: RESULT=new Factor_num(N1); RESULT.setLine(N1left); :}
			|
			(Factor_char) CHARACTER:C1 {: RESULT=new Factor_char(C1); RESULT.setLine(C1left); :}
			|
			(Factor_bool) BOOL:B1 {: RESULT=new Factor_bool(B1); RESULT.setLine(B1left); :}
			|
			(Factor_newexpr) NEW Type:T1 OPSQBRACKET Expr:E2 CLSQBRACKET {: RESULT=new Factor_newexpr(T1, E2); RESULT.setLine(T1left); :}
			|
			(Factor_expr) OPPAREN Expr:E1 CLPAREN {: RESULT=new Factor_expr(E1); RESULT.setLine(E1left); :}
			;		
					
Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :}; 

Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};

Relop ::= 	(Relop_eq) EQUAL {: RESULT=new Relop_eq(); :}
			|
			(Relop_neq) NOTEQUAL {: RESULT=new Relop_neq(); :}
			|
			(Relop_gr) GREATER {: RESULT=new Relop_gr(); :}
			|
			(Relop_greq) GREATEREQUAL {: RESULT=new Relop_greq(); :}
			|
			(Relop_l) LESS {: RESULT=new Relop_l(); :}
			|
			(Relop_leq) LESSEQUAL {: RESULT=new Relop_leq(); :}
			;
				
Addop ::= 	(Addop_p) PLUS {: RESULT=new Addop_p(); :}
			|
			(Addop_m) MINUS {: RESULT=new Addop_m(); :}
			;
			
Mulop ::=	(Mulop_m) MUL {: RESULT=new Mulop_m(); :}
			|
			(Mulop_d) DIV {: RESULT=new Mulop_d(); :}
			|
			(Mulop_md) MOD {: RESULT=new Mulop_md(); :}
			;

Setop ::= (Setop) UNION {: RESULT=new Setop(); :};
				
			